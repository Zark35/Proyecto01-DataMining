import requests
import pandas as pd
import json
from sqlalchemy import create_engine
from mage_ai.data_preparation.shared.secrets import get_secret_value

if 'data_loader' not in globals():
    from mage_ai.data_preparation.decorators import data_loader
if 'test' not in globals():
    from mage_ai.data_preparation.decorators import test


def _fetch_qb_data(realm_id, access_token, query, base_url, minor_version):
    """
    Llama a la API de QuickBooks y devuelve el JSON con los resultados
    """
    if not base_url or not minor_version:
        raise ValueError("Se requiere una URL base y el minor version")

    headers = {
        'Authorization': f'Bearer {access_token}',
        'Accept': 'application/json',
        'Content-Type': 'text/plain'
    }

    params = {
        'query': query,
        'minorversion': minor_version
    }

    url = f"{base_url.rstrip('/')}/v3/company/{realm_id}/query"

    try:
        response = requests.get(url, headers=headers, params=params, timeout=60)
        response.raise_for_status()
        data = response.json()
        print('‚úÖ Datos recibidos correctamente de QuickBooks')
        return data
    except requests.exceptions.RequestException as e:
        print(f'‚ùå Error en la API de QuickBooks: {e}')
        return None


def _save_to_postgres(df: pd.DataFrame, table_name: str):
    """
    Guarda un DataFrame en la base de datos Postgres
    """
    user = get_secret_value('pg_user')
    password = get_secret_value('pg_password')
    host = get_secret_value('pg_host')
    port = get_secret_value('pg_port')
    db = get_secret_value('pg_db')

    url_conn = f'postgresql://{user}:{password}@{host}:{port}/{db}'
    engine = create_engine(url_conn)

    df.to_sql(table_name, con=engine, if_exists='replace', index=False)
    print(f'‚úÖ Datos guardados en la tabla {table_name}')


def normalize_json(df: pd.DataFrame) -> pd.DataFrame:
    """
    Convierte dicts y listas en JSON string para que puedan guardarse en Postgres
    """
    for col in df.columns:
        df[col] = df[col].apply(
            lambda x: json.dumps(x) if isinstance(x, (dict, list)) else x
        )
    return df


@data_loader
def load_data_from_api(*args, **kwargs):
    """
    Pipeline de extracci√≥n y carga:
    1. Extrae datos de QuickBooks
    2. Convierte a DataFrame
    3. Normaliza JSONs anidados
    4. Guarda en Postgres
    """
    realm_id = get_secret_value('qb_realm_id')
    access_token = get_secret_value('qb_access_token')
    minor_version = 75
    query = 'select * from Invoice'
    base_url = 'https://sandbox-quickbooks.api.intuit.com'

    data = _fetch_qb_data(realm_id, access_token, query, base_url, minor_version)

    if data and 'QueryResponse' in data and 'Invoice' in data['QueryResponse']:
        invoices = data['QueryResponse']['Invoice']
        df = pd.DataFrame(invoices)

        # üîë Aqu√≠ se aplica la conversi√≥n antes de guardar
        df = normalize_json(df)

        _save_to_postgres(df, 'raw_invoices')

        return {"records_extracted": len(df)}
    else:
        return {"records_extracted": 0}


@test
def test_output(output, *args) -> None:
    """
    Verifica que el pipeline extraiga al menos un registro
    """
    assert "records_extracted" in output, "El bloque no devolvi√≥ la m√©trica esperada"
    print(f"‚úÖ {output['records_extracted']} registros extra√≠dos y guardados en Postgres")
